// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/kcarretto/paragon/ent/credential"
	"github.com/kcarretto/paragon/ent/target"
	"github.com/kcarretto/paragon/ent/task"
)

// TargetCreate is the builder for creating a Target entity.
type TargetCreate struct {
	config
	Name        *string
	PrimaryIP   *string
	MachineUUID *string
	PublicIP    *string
	PrimaryMAC  *string
	Hostname    *string
	LastSeen    *time.Time
	tasks       map[int]struct{}
	tags        map[int]struct{}
	credentials map[int]struct{}
}

// SetName sets the Name field.
func (tc *TargetCreate) SetName(s string) *TargetCreate {
	tc.Name = &s
	return tc
}

// SetPrimaryIP sets the PrimaryIP field.
func (tc *TargetCreate) SetPrimaryIP(s string) *TargetCreate {
	tc.PrimaryIP = &s
	return tc
}

// SetMachineUUID sets the MachineUUID field.
func (tc *TargetCreate) SetMachineUUID(s string) *TargetCreate {
	tc.MachineUUID = &s
	return tc
}

// SetNillableMachineUUID sets the MachineUUID field if the given value is not nil.
func (tc *TargetCreate) SetNillableMachineUUID(s *string) *TargetCreate {
	if s != nil {
		tc.SetMachineUUID(*s)
	}
	return tc
}

// SetPublicIP sets the PublicIP field.
func (tc *TargetCreate) SetPublicIP(s string) *TargetCreate {
	tc.PublicIP = &s
	return tc
}

// SetNillablePublicIP sets the PublicIP field if the given value is not nil.
func (tc *TargetCreate) SetNillablePublicIP(s *string) *TargetCreate {
	if s != nil {
		tc.SetPublicIP(*s)
	}
	return tc
}

// SetPrimaryMAC sets the PrimaryMAC field.
func (tc *TargetCreate) SetPrimaryMAC(s string) *TargetCreate {
	tc.PrimaryMAC = &s
	return tc
}

// SetNillablePrimaryMAC sets the PrimaryMAC field if the given value is not nil.
func (tc *TargetCreate) SetNillablePrimaryMAC(s *string) *TargetCreate {
	if s != nil {
		tc.SetPrimaryMAC(*s)
	}
	return tc
}

// SetHostname sets the Hostname field.
func (tc *TargetCreate) SetHostname(s string) *TargetCreate {
	tc.Hostname = &s
	return tc
}

// SetNillableHostname sets the Hostname field if the given value is not nil.
func (tc *TargetCreate) SetNillableHostname(s *string) *TargetCreate {
	if s != nil {
		tc.SetHostname(*s)
	}
	return tc
}

// SetLastSeen sets the LastSeen field.
func (tc *TargetCreate) SetLastSeen(t time.Time) *TargetCreate {
	tc.LastSeen = &t
	return tc
}

// SetNillableLastSeen sets the LastSeen field if the given value is not nil.
func (tc *TargetCreate) SetNillableLastSeen(t *time.Time) *TargetCreate {
	if t != nil {
		tc.SetLastSeen(*t)
	}
	return tc
}

// AddTaskIDs adds the tasks edge to Task by ids.
func (tc *TargetCreate) AddTaskIDs(ids ...int) *TargetCreate {
	if tc.tasks == nil {
		tc.tasks = make(map[int]struct{})
	}
	for i := range ids {
		tc.tasks[ids[i]] = struct{}{}
	}
	return tc
}

// AddTasks adds the tasks edges to Task.
func (tc *TargetCreate) AddTasks(t ...*Task) *TargetCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tc.AddTaskIDs(ids...)
}

// AddTagIDs adds the tags edge to Tag by ids.
func (tc *TargetCreate) AddTagIDs(ids ...int) *TargetCreate {
	if tc.tags == nil {
		tc.tags = make(map[int]struct{})
	}
	for i := range ids {
		tc.tags[ids[i]] = struct{}{}
	}
	return tc
}

// AddTags adds the tags edges to Tag.
func (tc *TargetCreate) AddTags(t ...*Tag) *TargetCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tc.AddTagIDs(ids...)
}

// AddCredentialIDs adds the credentials edge to Credential by ids.
func (tc *TargetCreate) AddCredentialIDs(ids ...int) *TargetCreate {
	if tc.credentials == nil {
		tc.credentials = make(map[int]struct{})
	}
	for i := range ids {
		tc.credentials[ids[i]] = struct{}{}
	}
	return tc
}

// AddCredentials adds the credentials edges to Credential.
func (tc *TargetCreate) AddCredentials(c ...*Credential) *TargetCreate {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return tc.AddCredentialIDs(ids...)
}

// Save creates the Target in the database.
func (tc *TargetCreate) Save(ctx context.Context) (*Target, error) {
	if tc.Name == nil {
		return nil, errors.New("ent: missing required field \"Name\"")
	}
	if tc.PrimaryIP == nil {
		return nil, errors.New("ent: missing required field \"PrimaryIP\"")
	}
	return tc.sqlSave(ctx)
}

// SaveX calls Save and panics if Save returns an error.
func (tc *TargetCreate) SaveX(ctx context.Context) *Target {
	v, err := tc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (tc *TargetCreate) sqlSave(ctx context.Context) (*Target, error) {
	var (
		res sql.Result
		t   = &Target{config: tc.config}
	)
	tx, err := tc.driver.Tx(ctx)
	if err != nil {
		return nil, err
	}
	builder := sql.Dialect(tc.driver.Dialect()).
		Insert(target.Table).
		Default()
	if value := tc.Name; value != nil {
		builder.Set(target.FieldName, *value)
		t.Name = *value
	}
	if value := tc.PrimaryIP; value != nil {
		builder.Set(target.FieldPrimaryIP, *value)
		t.PrimaryIP = *value
	}
	if value := tc.MachineUUID; value != nil {
		builder.Set(target.FieldMachineUUID, *value)
		t.MachineUUID = *value
	}
	if value := tc.PublicIP; value != nil {
		builder.Set(target.FieldPublicIP, *value)
		t.PublicIP = *value
	}
	if value := tc.PrimaryMAC; value != nil {
		builder.Set(target.FieldPrimaryMAC, *value)
		t.PrimaryMAC = *value
	}
	if value := tc.Hostname; value != nil {
		builder.Set(target.FieldHostname, *value)
		t.Hostname = *value
	}
	if value := tc.LastSeen; value != nil {
		builder.Set(target.FieldLastSeen, *value)
		t.LastSeen = *value
	}
	query, args := builder.Query()
	if err := tx.Exec(ctx, query, args, &res); err != nil {
		return nil, rollback(tx, err)
	}
	id, err := res.LastInsertId()
	if err != nil {
		return nil, rollback(tx, err)
	}
	t.ID = int(id)
	if len(tc.tasks) > 0 {
		p := sql.P()
		for eid := range tc.tasks {
			p.Or().EQ(task.FieldID, eid)
		}
		query, args := sql.Update(target.TasksTable).
			Set(target.TasksColumn, id).
			Where(sql.And(p, sql.IsNull(target.TasksColumn))).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
		affected, err := res.RowsAffected()
		if err != nil {
			return nil, rollback(tx, err)
		}
		if int(affected) < len(tc.tasks) {
			return nil, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"tasks\" %v already connected to a different \"Target\"", keys(tc.tasks))})
		}
	}
	if len(tc.tags) > 0 {
		for eid := range tc.tags {

			query, args := sql.Insert(target.TagsTable).
				Columns(target.TagsPrimaryKey[0], target.TagsPrimaryKey[1]).
				Values(id, eid).
				Query()
			if err := tx.Exec(ctx, query, args, &res); err != nil {
				return nil, rollback(tx, err)
			}
		}
	}
	if len(tc.credentials) > 0 {
		p := sql.P()
		for eid := range tc.credentials {
			p.Or().EQ(credential.FieldID, eid)
		}
		query, args := sql.Update(target.CredentialsTable).
			Set(target.CredentialsColumn, id).
			Where(sql.And(p, sql.IsNull(target.CredentialsColumn))).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
		affected, err := res.RowsAffected()
		if err != nil {
			return nil, rollback(tx, err)
		}
		if int(affected) < len(tc.credentials) {
			return nil, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"credentials\" %v already connected to a different \"Target\"", keys(tc.credentials))})
		}
	}
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	return t, nil
}
